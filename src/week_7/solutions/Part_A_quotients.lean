import tactic
/-

# Quotients

The quotient of a type by an equivalence relation.

## Overview

A binary relation on a type `X` is just a function `r : X → X → Prop`,
that is, a true-false statement attached to each pair of elements of `X`.

If `r` is also reflexive, symmetric and transitive, we say it is an
equivalence relation.

We will use notation `x ≈ y` for `r x y` below.

Given a type `X` and an equivalence relation `≈` on it, the type `clX` of
equivalence classes for `≈` comes equipped with a canonical function `X → clX`
(sending an element to its equivalence class), and it also satisfies a
universal property, namely that to give a map from `clX` to a type `T`
is to give a map `X → T` which is constant on equivalence classes. 

However Lean does not do quotients this way (even though it could).
It defines a new type `setoid X` of equivalence relations on `X`
(a type which we will essentially never use explicitly)
and if `s : setoid X` is an equivalence relation then it defines
`quotient s` to be a new type which satisfies the same universal property.
Hence there is a map `q : X → quotient s`, and to give a
map `f : quotient s → T` is to give `f ∘ q : X → T`, a map which is constant on
equivalence classes.

In this file we will learn the various useful functions which Lean has
for dealing with quotients -- that is, the key definitions and theorems
which mathematicians use, sometimes subconsciously, when dealing with
quotients.

## More on universal properties.

Recall that if `X` and `T` are types, then `X → T` denotes the *type*
of functions from `X` to `T`. A mathematician might call this
type `Hom(X,T)`. A term `f : X → T` of this type is just a function
from `X` to `T`.

Given a type `X` and an equivalence relation `≈` on `X`, we say that
a type `Q` and a function `f : X → Q` are the *quotient* of `X` by `≈`
if the following axiom holds:

(*) If `T` is any type then the map from the hom type `Hom(Q,T)` (also
known as `Q → T`) to `X → T` defined by sending `g : Q → T` to
`g ∘ f : X → T` induces a bijection
between `Q → T` and the subtype of `X → T` consisting of functions
`h : X → T` which are constant on equivalence classes (that is,
the functions `h : X → T` such that `x ≈ y → h x = h y`).

One can easily check that the type of equivalence classes for `≈` satisfies
this universal property. One can think of the type of equivalence classes
as a "model" for the quotient, in the same way that you might have seen
a model for the tensor product `V ⊗ W` of two vector spaces given
as a quotient of the vector space generated by pairs `(v,w)` by the subspace
generated by an appropriate collection of relations, or a model for
the localisation `R[1/S]` of a commutative ring at a multiplicative
subset given by `R × S` modulo a certain equivalence relation. 

Lean chooses a different model for the quotient of `X` by `≈`. It is
an opaque model, meaning that you cannot see what the terms are.
But Lean and mathlib give you a very solid API for the quotient.
In particular, the quotient satisfies the universal property, so one
can prove that it bijects with the type of equivalence classes on `X`.
However, after a while one moves away from the "equivalence class"
way of thinking, and starts thinking more abstractly about quotients,
and so ultimately one does not really need this bijection at all.

You might wonder why Lean does not use the type of equivalence classes.
The reason is not a mathematical one -- it is simply to do with an
implementation issue which I will mention later.

Here is a guided tour of the API for Lean's quotients, worked out for
a specific example -- the integers, as a quotient of ℕ² by the
equivalence relation (a,b) ≈ (c,d) ↔ a + d = b + c

-/

def nat2 := ℕ × ℕ

-- First I'll run you through the API for products `×`. 

/-

### products

The product of two types `X` and `Y` is `prod X Y`, with notation `X × Y`.
Hover over `×` to find out how to type it.

-/
section product

-- to make a term of a product, use round brackets.
def foo : nat2 := (3,4)

-- To extract the first term of a product, use `.1` or `.fst`

example : foo.1 = 3 := 
begin
  refl
end

example : foo.fst = 3 :=
begin
  refl
end

-- similarly use `.2` or `.snd` to get the second term

example : foo.snd = 4 := rfl -- term mode reflexivity of equality

-- The extensionality tactic works for products: a product is determined
-- by the two parts used to make it.
example (X : Type) (a b c d : X) (hac : a = c) (hbd : b = d) : (a,b) = (c,d) :=
begin
  ext,
  { dsimp only, -- tidy up
    -- ⊢ a = c
    exact hac },
  { -- don't bother tidying up
    exact hbd }
end

-- you can uses `cases x` on a product if you want to take it apart into
-- its two pieces
example (A B : Type) (x : A × B) (a : A) (b : B) (ha : a = x.1) (hb : b = x.2) : 
  x = (a,b) :=
begin
  cases x with c d,
  -- one way to tidy up
  dsimp only at ha, -- not actually needed
  -- another way
  change b = d at hb, -- also not needed
  rw [ha, hb],
  -- rw tries a sneaky `refl` and it works
end

end product

/-

## Worked example: ℤ as a quotient of ℕ²  

There's a surjection `ℕ × ℕ → ℤ` sending `(a,b)` to `a - b` (where here
`a` and `b` are regarded as integers). One checks easily that `(a,b)`
and `(c,d)` are sent to the same integer if and only if `a + d = b + c`.
Conversely one could just define an equivalence relation on ℕ × ℕ
by `x ≈ y ↔ x.1 + y.2 = x.2 + y.1` and then redefine ℤ -- or more
precisely define a second ℤ -- to be the quotient
by this equivalence relation. Let's call it `newint`.

-/

namespace newint

def r (x y : nat2) : Prop :=
x.1 + y.2 = x.2 + y.1

-- let's prove *two* "definitions" properties of `r`.
-- The first uses packaged pairs and .1 and .2
lemma r_def (x y : nat2) : r x y ↔ x.1 + y.2 = x.2 + y.1 :=
begin
  refl
end

-- The second uses explicit pairs
lemma r_def' (a b c d : ℕ) : r (a,b) (c,d) ↔ a + d = b + c :=
begin
  refl
end



def r_refl : reflexive r :=
begin
  -- you can start with `unfold reflexive` if you want to see what
  -- you're supposed to be proving here.
  intro x,
  cases x with a b,
  rw r_def',
  apply add_comm,
end

-- hint: 
def r_symm : symmetric r :=
begin
  rintros ⟨a, b⟩ ⟨c, d⟩ h,
  rw r_def' at *,
  linarith,
end

def r_trans : transitive r :=
begin
  rintros ⟨a, b⟩ ⟨c, d⟩ ⟨e, f⟩ h1 h2,
  rw r_def' at *,
  hint,
  linarith,
end
#exit

TODO:

⟦ ⟧
lift
≈ 

1) equiv classes = quotients
2) any surjection gives a quotient if you define the equiv reln right

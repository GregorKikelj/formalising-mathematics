import tactic
/-

# Quotients

The quotient of a type by an equivalence relation.

## Overview

A binary relation on a type `X` is just a function `r : X → X → Prop`,
that is, a true-false statement attached to each pair of elements of `X`.

If `r` is also reflexive, symmetric and transitive, we say it is an
equivalence relation.

We will use notation `x ≈ y` for `r x y` below.

Given a type `X` and an equivalence relation `≈` on it, the type `clX` of
equivalence classes for `≈` comes equipped with a canonical function `X → clX`
(sending an element to its equivalence class), and it also satisfies a
universal property, namely that to give a map from `clX` to a type `T`
is to give a map `X → T` which is constant on equivalence classes. 

However Lean does not do quotients this way (even though it could).
It defines a new type `setoid X` of equivalence relations on `X`
(a type which we will essentially never use explicitly)
and if `s : setoid X` is an equivalence relation then it defines
`quotient s` to be a new type which satisfies the same universal property.
Hence there is a map `q : X → quotient s`, and to give a
map `f : quotient s → T` is to give `f ∘ q : X → T`, a map which is constant on
equivalence classes.

In this file we will learn the various useful functions which Lean has
for dealing with quotients -- that is, the key definitions and theorems
which mathematicians use, sometimes subconsciously, when dealing with
quotients.

## More on universal properties.

Recall that if `X` and `T` are types, then `X → T` denotes the *type*
of functions from `X` to `T`. A mathematician might call this
type `Hom(X,T)`. A term `f : X → T` of this type is just a function
from `X` to `T`.

Given a type `X` and an equivalence relation `≈` on `X`, we say that
a type `Q` and a function `f : X → Q` are a *quotient* of `X` by `≈`
if the following axiom holds:

(*) If `T` is any type then the map from the hom type `Hom(Q,T)` (also
known as `Q → T`) to `X → T` defined by sending `g : Q → T` to
`g ∘ f : X → T` induces a bijection
between `Q → T` and the subtype of `X → T` consisting of functions
`h : X → T` which are constant on equivalence classes (that is,
the functions `h : X → T` such that `x ≈ y → h x = h y`).

Notation: we write `Q = X / ≈`. Note however that `Q` is only
defined up to unique isomorphism.

One can easily check that the type of equivalence classes for `≈` satisfies
this universal property. One can think of the type of equivalence classes
as a "model" for the quotient, in the same way that you might have seen
a model for the tensor product `V ⊗ W` of two vector spaces given
as a quotient of the vector space generated by pairs `(v,w)` by the subspace
generated by an appropriate collection of relations, or a model for
the localisation `R[1/S]` of a commutative ring at a multiplicative
subset given by `R × S` modulo a certain equivalence relation.

But there are far more general models for quotients. For example let's
say `X` and `Q` are any types, and `f : X → Q` is any surjection at all.
Define `≈` on `X` by `x ≈ y ↔ f x = f y`. It is easy to check that `Q` is a
quotient of `X` by `≈` simply because `Q` naturally bijects with the
equivalence classes of `≈`.

Lean does not use equivalence classes in its definition of `X / ≈`. It
chooses a different model. It is an opaque model, meaning that you cannot
actually see what the terms are.
But Lean and mathlib give you a very solid API for the quotient.
In particular, the quotient satisfies the universal property, so one
can prove that it bijects with the type of equivalence classes on `X`.
However, after a while one moves away from the "equivalence class"
way of thinking, and starts thinking more abstractly about quotients,
and so ultimately one does not really need this bijection at all.

You might wonder why Lean does not use the type of equivalence classes.
The reason is not a mathematical one -- it is simply to do with an
implementation issue which I will mention later.

Here is a guided tour of the API for Lean's quotients, worked out for
a specific example -- the integers, as a quotient of ℕ² by the
equivalence relation (a,b) ≈ (c,d) ↔ a + d = b + c

-/

-- N2 is much easier to type than `ℕ × ℕ` 
abbreviation N2 := ℕ × ℕ

-- First I'll run you through the API for products `×`. 

/-

### products

The product of two types `X` and `Y` is `prod X Y`, with notation `X × Y`.
Hover over `×` to find out how to type it.

-/
section product

-- to make a term of a product, use round brackets.
def foo : N2 := (3,4)

-- To extract the first term of a product, use `.1` or `.fst`

example : foo.1 = 3 := 
begin
  refl
end

example : foo.fst = 3 :=
begin
  refl
end

-- similarly use `.2` or `.snd` to get the second term

example : foo.snd = 4 := rfl -- term mode reflexivity of equality

-- The extensionality tactic works for products: a product is determined
-- by the two parts used to make it.
example (X : Type) (s t : X × X) (h1 : s.fst = t.fst) (h2 : s.snd = t.snd) :
  s = t :=
begin
  ext,
  { exact h1 },
  { exact h2 }
end

-- you can uses `cases x` on a product if you want to take it apart into
-- its two pieces
example (A B : Type) (x : A × B) : x = (x.1, x.2) :=
begin
  -- note that this is not `refl` -- you have to take `x` apart. 
  cases x with a b,
  dsimp only, -- to tidy up
  -- ⊢ (a, b) = (a, b)
  refl,
end

end product

/-

## Worked example: ℤ as a quotient of ℕ²  

There's a surjection `ℕ × ℕ → ℤ` sending `(a,b)` to `a - b` (where here
`a` and `b` are regarded as integers). One checks easily that `(a,b)`
and `(c,d)` are sent to the same integer if and only if `a + d = b + c`.
Conversely one could just define an equivalence relation on ℕ × ℕ
by `x ≈ y ↔ x.1 + y.2 = x.2 + y.1` and then redefine ℤ -- or more
precisely define a second ℤ -- to be the quotient
by this equivalence relation. Let's call it `Z`.

-/

namespace N2

def r (x y : N2) : Prop :=
x.1 + y.2 = y.1 + x.2

-- let's prove *two* "definitions" properties of `r`.
-- The first uses packaged pairs and .1 and .2
lemma r_def (x y : N2) : r x y ↔ x.1 + y.2 = y.1 + x.2 :=
begin
  refl
end

-- The second uses explicit pairs
lemma r_def' (a b c d : ℕ) : r (a,b) (c,d) ↔ a + d = c + b :=
begin
  refl
end

def r_refl : reflexive r :=
begin
  -- you can start with `unfold reflexive` if you want to see what
  -- you're supposed to be proving here.
  intro x,
  cases x with a b,
  rw r_def',
end

-- hint: `linarith` is good at linear arithmetic. 
def r_symm : symmetric r :=
begin
  rintros ⟨a, b⟩ ⟨c, d⟩ h,
  rw r_def' at *,
  linarith,
end

def r_trans : transitive r :=
begin
  rintros ⟨a, b⟩ ⟨c, d⟩ ⟨e, f⟩ h1 h2,
  rw r_def' at *,
  linarith,
end

-- now let's give N2 a setoid structure coming from `r`.
-- In other words, we tell the type class inference system
-- about `r`. Let's call it `setoid` and remember
-- we're in the `N2` namespace, so its full name
-- is N2.setoid
instance setoid : setoid N2 := ⟨r, r_refl, r_symm, r_trans⟩

-- Now we can use `≈` notation

example (x y : N2) : x ≈ y ↔ r x y :=
begin
  -- true by definition
  refl
end

-- `r x y` and `x ≈ y` are definitionally equal but not syntactically equal,
-- rather annoyingly, so `r_def` and `r_def'` are no longer of much use to us.
-- Let's make a new lemma which says the same thing with the new notation.
-- Let's teach it to `simp`.

@[simp] lemma equiv_def (x y : N2) : x ≈ y ↔ x.1 + y.2 = y.1 + x.2 :=
begin
  refl
end

end N2

-- Now we can take the quotient!
def Z := quotient N2.setoid

-- And now we can finally start.

-- The map from N2 to Z is called `quotient.mk`
-- Recall `foo` is `(3,4)`

def bar : Z := quotient.mk foo -- bar is the image of `foo` in the quotient.
-- so it's morally -1.

-- Notation for `quotient.mk x` is `⟦x⟧`
example : bar = ⟦foo⟧ :=
begin
  refl
end

/-

## Z

We have a new type `Z` now, and a way of going from `N2`
to `Z` (`quotient.mk`, with notation `⟦ ⟧`). 

Here then are some things we can think about:

(1) How to prove the universal property for `Z`?
(2) How to put a ring structure on `Z`?
(3) How to define a map from `Z` to Lean's `ℤ`, which
is not defined as a quotient but also satisfies the
universal property?

Let's start with (1). The claim is that to give
a map `Z → T` is to give a map `N2 → T`
which is constant on equivalence classes. The
construction: given a map `Z → T`, just
compose with `quotient.mk : N2 → Z`.
What do we need to prove here?

First we need to prove that composing with `quotient.mk`
gives us a map which is constant on equivalence classes!
This follows from the statement that `quotient.mk` sends
equivalent elements to equal elements. In other words,
we need to prove `x ≈ y → ⟦x⟧ = ⟦y⟧`.

-/

example (x y : N2) : x ≈ y → ⟦x⟧ = ⟦y⟧ :=
quotient.sound

-- Of course we know the other implication is also true.
-- This is called `quotient.exact`.

example (x y : N2) : ⟦x⟧ = ⟦y⟧ → x ≈ y :=
quotient.exact

-- The iff statement (useful for rewrites) is called `quotient.eq` :

example (x y : N2) : ⟦x⟧ = ⟦y⟧ ↔ x ≈ y :=
quotient.eq

-- So now we can define the map in one direction:

variable {T : Type}

/- Given a map `g : Z → T`, make a function `f : N2 → T` which is
   constant on equivalence classes. -/
def universal1 (g : Z → T) :
  {f : N2 → T // ∀ x y : N2, x ≈ y → f x = f y} :=
⟨λ n2, g ⟦n2⟧, begin
  intros x y h,
  rw ← quotient.eq at h,
  rw h,
end⟩

-- To go the other way, we use a new function called `quotient.lift`.
-- Note that this is a weird name for the construction, at least if your
-- mental picture has the quotient underneath the type with the relation.
-- But we're stuck with it.

/- Given a map `f : N2 → T` plus the assumption that it is constant on
   equivalence classes, "lift" this map to a map `Z → T`. -/
def universal2 (f : N2 → T) (hf : ∀ x y : N2, x ≈ y → f x = f y) :
  Z → T :=
quotient.lift f hf

-- So now the big question is: how do we prove that these two constructions
-- are inverse to each other? In other words, what is the API for `quotient.lift`?
-- Let's start by showing that going from `N2 → T` to `Z → T` and then
-- back to `N2 → T` is the identity function.

example (f : N2 → T) (hf : ∀ x y : N2, x ≈ y → f x = f y) :
  f = λ n2, quotient.lift f hf ⟦n2⟧ :=
begin
  -- true by definition!
  refl
end

-- This is the reason quotients are defined as a black box; if we had
-- defined them to be equivalence classes this would be true, but
-- not by definition.

-- To go the other way, the key thing to know is a function 
-- called `quotient.induction_on`:

example (g : Z → T) : g = quotient.lift (λ n2, g ⟦n2⟧) (universal1 g).2 :=
begin
  -- two functions are equal if they agree on all inputs
  ext z,
  -- now use `quotient.induction_on`
  apply quotient.induction_on z,
  -- and now we're in the situation of the above example again
  intros,
  -- so it's true by definition.
  refl,
end

/-

## Giving Z a ring structure

-/

namespace Z -- so we are defining `Z.zero`, `Z.add` etc.

open N2 -- so we can use `equiv_def` rather than `N2.equiv_def`

/-

### zero and one

We start by giving `Z` a zero and a one.

-/

def zero : Z := ⟦(0, 0)⟧

def one : Z := ⟦(1, 0)⟧

-- We don't have the numeral notation yet though:

-- #check (0 : Z) -- error about failing to find an instance of `has_zero Z`

-- Let's use numeral notation `0` and `1` for `zero` and `one`.

instance : has_zero Z := ⟨zero⟩
instance : has_one Z := ⟨one⟩

-- let's start to train the simplifier
@[simp] lemma zero_def : (0 : Z) = ⟦(0, 0)⟧ := rfl -- now works 
@[simp] lemma one_def : (1 : Z) = ⟦(1, 0)⟧ := rfl

/-

### negation

Let's do negation next, by which I mean `-z`, because this is a function
which only takes one input.

Here is how a mathematician might describe defining negation on the
equivalence classes of `ℕ × ℕ`. They might say this:

1) choose an element `z` of the quotient `Z`.
2) lift it randomly to a pair `(a, b)` of natural numbers.
3) Define `-z` to be `⟦(b,a)⟧`
4) Now let us check that this definition did not depend on the random lift in (2):
   [and then they prove a lemma saying the construction is well-defined, i.e.
    that if `(a, b) ~ (c,d)` then `⟦(b, a)⟧ = ⟦(d, c)⟧` ]

This is the way mathematicians are taught. We will use *the same
construction* in Lean but we will phrase it differently.

1') Define an auxiliary map N2 → Z by sending `(a,b)` to `⟦(b,a)⟧`
2') Now use `quotient.lift` to descend this to a map from `Z` to `Z`.
3') We need to supply as an input to `quotient.lift` the theorem saying
    that this map is constant on equivalence classes.
    [and then we prove a lemma saying `(a, b) ~ (c, d) → ⟦(b, a)⟧ = ⟦(d, c)⟧`

So as you can see, the mathematics is the same, but the emphasis is slightly
different. 
-/

def neg_aux (xy : N2) : Z := ⟦(xy.2, xy.1)⟧

-- useful for rewriting. Let's teach it to `simp`.
@[simp] lemma neg_aux_def (xy : N2) : neg_aux xy = ⟦(xy.2, xy.1)⟧ := rfl
  -- true by def

def neg : Z → Z := quotient.lift neg_aux 
begin
  rintros ⟨a, b⟩ ⟨c, d⟩ h,
  rw [neg_aux_def, neg_aux_def, quotient.eq],
  rw equiv_def at *,
  dsimp only at *,
  linarith,
end

-- `-z` notation
instance : has_neg Z := ⟨neg⟩

@[simp] lemma neg_def (a b : ℕ) : (-⟦(a, b)⟧ : Z) = ⟦(b, a)⟧ := rfl
/-

## Addition

If we use `quotient.lift` for defining addition, we'd have to use it twice.
We define `⟦(a, b)⟧ + ⟦(c, d)⟧ = ⟦(a + c, b + d)⟧` and would then have
to check it was independent of the choice of lift `(a, b)` in one lemma,
and then in a second proof check it was independent of the choice of `(c, d)`.
The variant `quotient.lift₂` enables us to prove both results in one go. 
It says that if `f : A → B → C` is a function which and `A` and `B`
have equivalence relations on them, and `f` is constant on equivalence
classes in both the `A` and the `B` variable, then `f` descends ("lifts")
to a function `A/~ → B/~ → C`.
-/

-- auxiliary definition of addition 
def add_aux (ab cd : N2) : Z := ⟦(ab.1 + cd.1, ab.2 + cd.2)⟧

-- useful for rewriting
@[simp] lemma add_aux_def (ab cd : N2) :
  add_aux ab cd = ⟦(ab.1 + cd.1, ab.2 + cd.2)⟧ :=
rfl -- true by def

def add : Z → Z → Z := quotient.lift₂ add_aux 
begin
  rintros ⟨a, b⟩ ⟨c, d⟩ ⟨e, f⟩ ⟨g, h⟩ h1 h2,
  simp at *,
  linarith,
end

-- notation for addition
instance : has_add Z := ⟨add⟩

@[simp] lemma add_def (a b c d : ℕ) : (⟦(a, b)⟧ + ⟦(c, d)⟧ : Z) = ⟦(a+c, b+d)⟧ := rfl

def sub (x y : Z) : Z := x + -y

instance : has_sub Z := ⟨sub⟩

/-

## Z is a commutative group under addition

-/

def add_comm_group : add_comm_group Z :=
{ zero := 0,
  add := (+),
  neg := has_neg.neg, -- there is no trick to use `-` because Lean confuses it with subtraction :-(
  sub := has_sub.sub,
  zero_add := begin
    intro x,
    apply quotient.induction_on x, clear x,
    rintro ⟨a, b⟩,
    simp,
  end,
  add_zero := begin
    intro x,
    apply quotient.induction_on x, clear x,
    rintro ⟨a, b⟩,
    simp,
  end,    
  add_assoc := begin
    intros x y z,
    refine quotient.induction_on₃ x y z _, clear x y z,
    rintros ⟨a, b⟩ ⟨c, d⟩ ⟨e, f⟩,
    simp,
    ring,
  end,
  add_left_neg := begin
    intro x,
    apply quotient.induction_on x, clear x,
    rintro ⟨a, b⟩,
    simp,
    ring,
  end,
  add_comm := begin
    intros x y,
    apply quotient.induction_on₂ x y, clear x y,
    rintro ⟨a, b⟩ ⟨c, d⟩,
    simp,
    ring,
  end,
}

/-

## More of the same : Z is a commutative ring.

I would recommend skipping this and going onto Part B.
There are no more ideas here, this is just to prove that it can be done.

A mild variant: let's do multiplication in a slightly different way.
Instead of using `quotient.lift₂` we'll use `quotient.map₂`,
which descends a map `N2 → N2 → N2` to a map `Z → Z → Z`.

-/

-- auxiliary definition of multiplication: `(a-b)*(c-d) = (a*c+b*d)-(a*d+b*c)`
def mul_aux (ab cd : N2) : N2 :=
  (ab.1 * cd.1 + ab.2 * cd.2, ab.1 * cd.2 + ab.2 * cd.1)

@[simp] lemma mul_aux_def (a b c d : ℕ) :
  mul_aux (a,b) (c,d) = (a*c+b*d,a*d+b*c) := rfl

def mul : Z → Z → Z := quotient.map₂ mul_aux 
begin
  rintros ⟨a, b⟩ ⟨c, d⟩ h1 ⟨e, f⟩ ⟨g, h⟩ h2,
  simp at *,
  nlinarith,
end

-- notation for multiplication
instance : has_mul Z := ⟨mul⟩

@[simp] lemma mul_def (a b c d : ℕ) :
  (⟦(a, b)⟧ * ⟦(c, d)⟧ : Z) = ⟦(a*c+b*d, a*d+b*c)⟧ := rfl

-- now let's prove that Z is a commutative ring!

def comm_ring : comm_ring Z :=
{ one := 1,
  add := (+),
  mul := (*),
  mul_assoc := begin
    intros x y z,
    apply quotient.induction_on₃ x y z, clear x y z,
    rintros ⟨a, b⟩ ⟨c, d⟩ ⟨e, f⟩,
    simp,
    ring,
  end,
  one_mul := begin
    intro x,
    apply quotient.induction_on x, clear x,
    rintro ⟨a, b⟩,
    simp,
  end,
  mul_one := begin
    intro x,
    apply quotient.induction_on x, clear x,
    rintro ⟨a, b⟩,
    simp,
  end,
  left_distrib := begin
    intros x y z,
    apply quotient.induction_on₃ x y z, clear x y z,
    rintros ⟨a, b⟩ ⟨c, d⟩ ⟨e, f⟩,
    simp [add_comm_group.add],
    ring,
  end,
  right_distrib := begin
    intros x y z,
    apply quotient.induction_on₃ x y z, clear x y z,
    rintros ⟨a, b⟩ ⟨c, d⟩ ⟨e, f⟩,
    simp,
    ring,
  end,
  mul_comm := begin
    intros x y,
    apply quotient.induction_on₂ x y, clear x y,
    rintro ⟨a, b⟩ ⟨c, d⟩,
    simp,
    ring,
  end,
  ..add_comm_group
}

#exit

-- /-

-- ## ordering

-- -/

-- def le_aux (ab cd : N2) : Prop :=
-- ab.1 + cd.2 ≤ cd.1 + ab.2

-- def le : Z → Z → Prop :=
-- quotient.lift₂ le_aux begin
--   rintros ⟨a, b⟩ ⟨c, d⟩ ⟨e, f⟩ ⟨g, h⟩ h1 h2,
--   simp [le_aux] at *,
--   split,
--   { intros,
--     linarith },
--   { intros,
--     linarith }
-- end

-- instance : has_le Z := ⟨le⟩

-- @[simp] lemma le_def (a b c d : ℕ) :
-- @has_le.le Z Z.has_le (⟦(a, b)⟧ : Z) (⟦(c, d)⟧ : Z) ↔ a + d ≤ c + b :=
-- begin
--   refl,
-- end



-- noncomputable instance : linear_order Z :=
-- { le := (≤),
--   le_refl := begin
--     intro a,
--     apply quotient.induction_on a, clear a,
--     rintro ⟨a, b⟩,
--     simp,
--   end,
--   le_trans := begin
--     intros a b c,
--     apply quotient.induction_on₃ a b c, clear a b c,
--     rintros ⟨a, b⟩ ⟨c, d⟩ ⟨e, f⟩ h1 h2,
--     simp at *,
--     linarith,
--   end,
--   le_antisymm := begin
--     intros a b,
--     apply quotient.induction_on₂ a b, clear a b,
--     rintros ⟨a, b⟩ ⟨c, d⟩ h1 h2,
--     simp at *,
--     linarith,
--   end,
--   le_total := begin
--     intros a b,
--     apply quotient.induction_on₂ a b, clear a b,
--     rintros ⟨a, b⟩ ⟨c, d⟩,
--     simp at *,
--     exact le_total (a + d) (c + b),
--   end,
--   decidable_le := by classical; apply_instance,
--   decidable_eq := by classical; apply_instance,
--   decidable_lt := by classical; apply_instance, }
/-

## induction principle

-/

theorem induction_on (P : Z → Prop) (h0 : P 0) (hplus : ∀ z, P z → P (z + 1))
  (hminus : ∀ z, P z → P (z - 1)) : ∀ z, P z :=
begin
  sorry
end

/-

## initial object in category of pointed set with a bijection

-/

example (X : Type) (x : X) (f : X ≃ X) :
  ∃! g : Z → X, g 0 = x ∧ ∀ z : Z, f (g z) = g (z + 1) :=
begin
  sorry
end


/-

## Proving that `Z` is isomorphic to ℤ

-/

def Zequiv : Z ≃ ℤ :=
{ to_fun := quotient.lift (λ ab : N2, (ab.1 : ℤ) - ab.2) begin
    rintros ⟨a, b⟩ ⟨c, d⟩ hab,
    rw equiv_def at hab,
    dsimp at *,
    linarith,
  end,
  inv_fun := λ z, if 0 ≤ z then ⟦(z.nat_abs, 0)⟧ else ⟦(0, z.nat_abs)⟧,
  left_inv := begin
    intro x,
    simp,
    split_ifs,
    sorry, -- urgh
    sorry
  end,
  right_inv := sorry }

#exit

import tactic
/-

# Quotients

The quotient of a type by an equivalence relation.

## Overview

A binary relation on a type `X` is just a function `r : X → X → Prop`,
that is, a true-false statement attached to each pair of elements of `X`.

If `r` is also reflexive, symmetric and transitive, we say it is an
equivalence relation.

We will use notation `x ≈ y` for `r x y` below.

Given a type `X` and an equivalence relation `≈` on it, the type `clX` of
equivalence classes for `≈` comes equipped with a canonical function `X → clX`
(sending an element to its equivalence class), and it also satisfies a
universal property, namely that to give a map from `clX` to a type `T`
is to give a map `X → T` which is constant on equivalence classes. 

However Lean does not do quotients this way (even though it could).
It defines a new type `setoid X` of equivalence relations on `X`
(a type which we will essentially never use explicitly)
and if `s : setoid X` is an equivalence relation then it defines
`quotient s` to be a new type which satisfies the same universal property.
Hence there is a map `q : X → quotient s`, and to give a
map `f : quotient s → T` is to give `f ∘ q : X → T`, a map which is constant on
equivalence classes.

In this file we will learn the various useful functions which Lean has
for dealing with quotients -- that is, the key definitions and theorems
which mathematicians use, sometimes subconsciously, when dealing with
quotients.

## More on universal properties.

Recall that if `X` and `T` are types, then `X → T` denotes the *type*
of functions from `X` to `T`. A mathematician might call this
type `Hom(X,T)`. A term `f : X → T` of this type is just a function
from `X` to `T`.

Given a type `X` and an equivalence relation `≈` on `X`, we say that
a type `Q` and a function `f : X → Q` are the *quotient* of `X` by `≈`
if the following axiom holds:

(*) If `T` is any type then the map from the hom type `Hom(Q,T)` (also
known as `Q → T`) to `X → T` defined by sending `g : Q → T` to
`g ∘ f : X → T` induces a bijection
between `Q → T` and the subtype of `X → T` consisting of functions
`h : X → T` which are constant on equivalence classes (that is,
the functions `h : X → T` such that `x ≈ y → h x = h y`).

One can easily check that the type of equivalence classes for `≈` satisfies
this universal property. One can think of the type of equivalence classes
as a "model" for the quotient, in the same way that you might have seen
a model for the tensor product `V ⊗ W` of two vector spaces given
as a quotient of the vector space generated by pairs `(v,w)` by the subspace
generated by an appropriate collection of relations, or a model for
the localisation `R[1/S]` of a commutative ring at a multiplicative
subset given by `R × S` modulo a certain equivalence relation. 

Lean chooses a different model for the quotient of `X` by `≈`. It is
an opaque model, meaning that you cannot see what the terms are.
But Lean and mathlib give you a very solid API for the quotient.
In particular, the quotient satisfies the universal property, so one
can prove that it bijects with the type of equivalence classes on `X`.
However, after a while one moves away from the "equivalence class"
way of thinking, and starts thinking more abstractly about quotients,
and so ultimately one does not really need this bijection at all.

You might wonder why Lean does not use the type of equivalence classes.
The reason is not a mathematical one -- it is simply to do with an
implementation issue which I will mention later.

Here is a guided tour of the API for Lean's quotients, worked out for
a specific example -- the integers, as a quotient of ℕ² by the
equivalence relation (a,b) ≈ (c,d) ↔ a + d = b + c

-/

-- N2 is much easier to type than `ℕ × ℕ` 
def N2 := ℕ × ℕ

-- First I'll run you through the API for products `×`. 

/-

### products

The product of two types `X` and `Y` is `prod X Y`, with notation `X × Y`.
Hover over `×` to find out how to type it.

-/
section product

-- to make a term of a product, use round brackets.
def foo : N2 := (3,4)

-- To extract the first term of a product, use `.1` or `.fst`

example : foo.1 = 3 := 
begin
  refl
end

example : foo.fst = 3 :=
begin
  refl
end

-- similarly use `.2` or `.snd` to get the second term

example : foo.snd = 4 := rfl -- term mode reflexivity of equality

-- The extensionality tactic works for products: a product is determined
-- by the two parts used to make it.
example (X : Type) (s t : X × X) (h1 : s.fst = t.fst) (h2 : s.snd = t.snd) :
  s = t :=
begin
  ext,
  { exact h1 },
  { exact h2 }
end

-- you can uses `cases x` on a product if you want to take it apart into
-- its two pieces
example (A B : Type) (x : A × B) : x = (x.1, x.2) :=
begin
  -- note that this is not `refl` -- you have to take `x` apart. 
  cases x with a b,
  dsimp only, -- to tidy up
  -- ⊢ (a, b) = (a, b)
  refl,
end

end product

/-

## Worked example: ℤ as a quotient of ℕ²  

There's a surjection `ℕ × ℕ → ℤ` sending `(a,b)` to `a - b` (where here
`a` and `b` are regarded as integers). One checks easily that `(a,b)`
and `(c,d)` are sent to the same integer if and only if `a + d = b + c`.
Conversely one could just define an equivalence relation on ℕ × ℕ
by `x ≈ y ↔ x.1 + y.2 = x.2 + y.1` and then redefine ℤ -- or more
precisely define a second ℤ -- to be the quotient
by this equivalence relation. Let's call it `Z`.

-/

namespace N2

def r (x y : N2) : Prop :=
x.1 + y.2 = x.2 + y.1

-- let's prove *two* "definitions" properties of `r`.
-- The first uses packaged pairs and .1 and .2
lemma r_def (x y : N2) : r x y ↔ x.1 + y.2 = x.2 + y.1 :=
begin
  refl
end

-- The second uses explicit pairs
lemma r_def' (a b c d : ℕ) : r (a,b) (c,d) ↔ a + d = b + c :=
begin
  refl
end

def r_refl : reflexive r :=
begin
  -- you can start with `unfold reflexive` if you want to see what
  -- you're supposed to be proving here.
  intro x,
  cases x with a b,
  rw r_def',
  apply add_comm,
end

-- hint: `linarith` is good at linear arithmetic. 
def r_symm : symmetric r :=
begin
  rintros ⟨a, b⟩ ⟨c, d⟩ h,
  rw r_def' at *,
  linarith,
end

def r_trans : transitive r :=
begin
  rintros ⟨a, b⟩ ⟨c, d⟩ ⟨e, f⟩ h1 h2,
  rw r_def' at *,
  linarith,
end

-- now let's give N2 a setoid structure coming from `r`.
-- In other words, we tell the type class inference system
-- about `r`. Let's call it `setoid` and remember
-- we're in the `N2` namespace, so its full name
-- is N2.setoid
instance setoid : setoid N2 := ⟨r, r_refl, r_symm, r_trans⟩

-- Now we can use `≈` notation

example (x y : N2) : x ≈ y ↔ r x y :=
begin
  -- true by definition
  refl
end

end N2

-- Now we can take the quotient!
def Z := quotient N2.setoid

-- And now we can finally start.

-- The map from N2 to Z is called `quotient.mk`
-- Recall `foo` is `(3,4)`

def bar : Z := quotient.mk foo -- bar is the image of `foo` in the quotient.
-- so it's morally -1.

-- Notation for `quotient.mk x` is `⟦x⟧`
example : bar = ⟦foo⟧ :=
begin
  refl
end

/-

## Z

We have a new type `Z` now, and a way of going from `N2`
to `Z` (`quotient.mk`, with notation `⟦ ⟧`). 

Here then are some things we can think about:

(1) How to prove the universal property for `Z`?
(2) How to put a ring structure on `Z`?
(3) How to define a map from `Z` to Lean's `ℤ`, which
is not defined as a quotient but also satisfies the
universal property?

Let's start with (1). The claim is that to give
a map `Z → T` is to give a map `ℕ × ℕ → T`
which is constant on equivalence classes. The
construction: given a map `Z → T`, just
compose with `quotient.mk : ℕ × ℕ → Z`. 
To check that this map is constant on equivalence
classes, we just need to prove `x ≈ y → ⟦x⟧ = ⟦y⟧`.

-/

example (x y : N2) : x ≈ y → ⟦x⟧ = ⟦y⟧ :=
quotient.sound

-- While we're here, the other direction is called `quotient.exact`

example (x y : N2) : ⟦x⟧ = ⟦y⟧ → x ≈ y :=
quotient.exact

-- and the equivalence is called `quotient.eq` :

example (x y : N2) : ⟦x⟧ = ⟦y⟧ ↔ x ≈ y :=
quotient.eq

-- So now we can define the map in one direction:

variable {T : Type}

def universal1 (g : Z → T) :
  {f : N2 → T // ∀ x y : N2, x ≈ y → f x = f y} :=
⟨λ n2, g ⟦n2⟧, begin
  intros x y h,
  rw ← quotient.eq at h,
  rw h,
end⟩

-- To go the other way, we use a new function called `quotient.lift`.
-- Note that this is a weird name for the construction, at least if your
-- mental picture has the quotient underneath the type with the relation.
-- But we're stuck with it.

def universal2 (f : N2 → T) (hf : ∀ x y : N2, x ≈ y → f x = f y) :
  Z → T :=
quotient.lift f hf

-- So now the big question is: how do we prove that these two constructions
-- are inverse to each other? In other words, what is the API for `quotient.lift`?
-- Let's start by showing how to get from f to g to f:

example (f : N2 → T) (hf : ∀ x y : N2, x ≈ y → f x = f y) :
  f = λ n2, quotient.lift f hf ⟦n2⟧ :=
begin
  -- true by definition!
  refl
end

-- This is the reason quotients are defined as a black box; if we had
-- defined them to be equivalence classes this would be true, but
-- not by definition.

-- To go the other way, the key thing to know is a function 
-- called `quotient.induction_on`:

example (g : Z → T) : g = quotient.lift (λ n2, g ⟦n2⟧) (universal1 g).2 :=
begin
  -- two functions are equal if they agree on all inputs
  ext z,
  -- now use `quotient.induction_on`
  apply quotient.induction_on z,
  -- and now we're in the situation of the above example again
  intros,
  -- so it's true by definition.
  refl,
end




#exit

TODO:

lift

1) equiv classes = quotients
2) any surjection gives a quotient if you define the equiv reln right

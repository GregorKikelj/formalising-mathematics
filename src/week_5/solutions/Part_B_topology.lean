import topology.subset_properties

variables (X Y : Type) [topological_space X] [topological_space Y] (f : X → Y)

open filter set

open_locale filter -- for 𝓟
open_locale topological_space -- for 𝓝 

/-

## Neighbourhood filters

If `α` is a topological space and `a : α` then `𝓝 a` is the following
filter on `α`: `X ∈ 𝓝 a` if and only if `X` contains an open neighbourhood
of `a`, or equivalently if `a` is in the interior of `X`. Let's use the
API for interior and closure, and check that this is a filter.

Useful stuff from the topological space API:
`interior_univ : interior univ = univ`
`mem_univ x : x ∈ univ`
`interior_mono : s ⊆ t → interior s ⊆ interior t`
and guess what this is called:
`??? : interior (s ∩ t) = interior s ∩ interior t`
-/

variables {α : Type*} [topological_space α]

open set

-- neighbourhood filter 𝓝 a on α 
example (a : α): filter α :=
{ sets := {X : set α | a ∈ interior X},
  univ_sets := begin
    rw mem_set_of_eq,
    rw interior_univ,
    exact mem_univ a,
  end,
  sets_of_superset := begin
    intros X Y haX hXY,
    rw mem_set_of_eq at *,
    exact interior_mono hXY haX,
  end,
  inter_sets := begin
    intros X Y hX hY,
    rw mem_set_of_eq at *,
    rw interior_inter,
    exact ⟨hX, hY⟩
  end }

/-

A cluster point of a filter `F : filter α` (also known as an accumulation
point or a limit point) is `x : α` such that `𝓝 x ⊓ F ≠ ⊥`. Whatever
does this mean? Recall that the order on filters is upside-down, so
`𝓝 x ⊓ F` means the filter generated by `F` and the neighbourhoods of `x`,
and `⊥` is the filter which contains every subset! So this boils down
to saying that there do not exists sets `A ∈ 𝓝 x` and `B ∈ F` such that `A ∩ B = ∅`,
or, in other words, every element of the filter intersects every neighbourhood
of `x`. To give an example, if `S` is any subset of `α` then the cluster
points of `𝓟 S` are just the points `x` such that any open set containing `x`
meets `S`, or equivalently that `x` is in the closure of `S`.

-/

-- The below lemma is called `cluster_pt.mono` in mathlib. See if you can prove
-- it. Start by rewriting `cluster_pt_iff`.

example {x : α} {F G : filter α} (hxF : cluster_pt x F) (hFG : F ≤ G) :
  cluster_pt x G :=
begin
  rw cluster_pt_iff at hxF ⊢,
  intros,
  apply hxF hU,
  rw filter.le_def at hFG,
  apply hFG _ hV,
end

/-

So here is another proof that a closed subset of a compact space is compact.
As before, we prove that the intersection of a compact subset and a closed
subset is a compact subset.

This time we will use mathlib's actual definition of `is_compact`: 
A set `s` is compact if for every filter `f ≠ ⊥` that contains `s`,
there exists `a` such that every set of `f` also meets every
neighborhood of `a`.

Here's the actual definition in mathlib:

`def is_compact (s : set α) := ∀ ⦃f⦄ [ne_bot f], f ≤ 𝓟 s → ∃a∈s, cluster_pt a f`

Note that `ne_bot f` is in square brackets, which means that the type
class inference system is supposed to supply it. We will explicitly
add this fact into the type class inference system with `haveI` below.

Now here's a suggestion for a proof. 
First show that by compactness of `s`, we can find a cluster point
`a` for `f` in `s`. 
Now show that this cluster point is in `t` too, 
because `t` is closed. You might find 

`is_closed.closure_eq : is_closed t → closure t = t`

useful, and also

`mem_closure_iff_cluster_pt : a ∈ closure S ↔ cluster_pt a (𝓟 S)`

-/

lemma closed_of_compact (s : set X) (hs : is_compact s)
  (t : set X) (ht : is_closed t) : is_compact (s ∩ t) :=
begin
  -- assume f is a filter which is not bot, and is ≤ the principal
  -- filter on s ∩ t (i.e. which contains `s ∩ t`). We need to find a
  -- cluster point for f which is in s ∩ t.
  intros f hnf hstf,
  -- Let's tell the type class inference system about `hnf : f.ne_bot`
  haveI := hnf,
  -- see if you can take it from here.
  obtain ⟨a, has, ha⟩ : ∃ a ∈ s, cluster_pt a f,
  { apply hs,
    apply le_trans hstf,
    rw principal_mono,
    apply inter_subset_left },
  -- we claim that this cluster point is in `t` too.
  have hat : a ∈ t,
  { -- It suffices to prove a ∈ closure t
    rw ← ht.closure_eq,
    -- or equivalently that `a` is a cluster point for `𝓟 t`
    rw mem_closure_iff_cluster_pt,
    -- but `a` is a cluster point for `f`
    -- so by cluster_pt.mono 
    apply cluster_pt.mono ha,
    -- it suffices to prove f ≤ 𝓟 t. 
    -- but f ≤ 𝓟 (s ∩ t) so this is now straightforward
    refine le_trans hstf _,
    rw principal_mono,
    apply inter_subset_right },
  -- so this `a` works
  exact ⟨a, ⟨has, hat⟩, ha⟩
end

#exit

lemma comap_inf_principal_ne_bot_of_image_mem {α β : Type*}
  {f : filter β} {m : α → β}
  (hf : ne_bot f) {s : set α} (hs : m '' s ∈ f) :
  ne_bot (comap m f ⊓ 𝓟 s) :=
begin
  refine compl_compl s ▸ mt mem_sets_of_eq_bot _,
  rintros ⟨t, ht, hts⟩,
  rcases hf.nonempty_of_mem (inter_mem_sets hs ht) with ⟨_, ⟨x, hxs, rfl⟩, hxt⟩,
  exact absurd hxs (hts hxt)
end


lemma image_compact_of_compact (hf : continuous f) (s : set X)
  (hs : is_compact s) :
  is_compact (f '' s) :=
begin
  intros l lne ls,
  have : ne_bot (l.comap f ⊓ 𝓟 s) :=
    comap_inf_principal_ne_bot_of_image_mem lne (le_principal_iff.1 ls),
  obtain ⟨a, has, ha⟩ : ∃ a ∈ s, cluster_pt a (l.comap f ⊓ 𝓟 s) := @@hs this inf_le_right,
  use [f a, mem_image_of_mem f has],
  have : tendsto f (𝓝 a ⊓ (comap f l ⊓ 𝓟 s)) (𝓝 (f a) ⊓ l),
  { have this1 : continuous_within_at f s a := continuous.continuous_within_at hf,
    have this2 := this1.inf,
    have this3 := this2 (@tendsto_comap _ _ f l),
    convert this3 using 1,
    rw nhds_within,
    ac_refl },
  exact @@tendsto.ne_bot _ this ha,
end




